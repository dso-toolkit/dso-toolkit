diff --git a/dist/index.cjs.js b/dist/index.cjs.js
index 42d26c6fc5ee9c32007dc3e485bf302e145a5dfe..f5503bcab4323748ac66a41d634895935522716b 100644
--- a/dist/index.cjs.js
+++ b/dist/index.cjs.js
@@ -189,7 +189,7 @@ const createAngularComponentDefinition = (tagName, inputs, outputs, methods, inc
     // Formats the input strings into comma separated, single quoted values.
     const formattedInputs = formatToQuotedList(inputs);
     // Formats the output strings into comma separated, single quoted values.
-    const formattedOutputs = formatToQuotedList(outputs);
+    const formattedOutputs = formatToQuotedList(outputs.map((event) => event.name));
     // Formats the method strings into comma separated, single quoted values.
     const formattedMethods = formatToQuotedList(methods);
     const proxyCmpOptions = [];
@@ -209,6 +209,12 @@ const createAngularComponentDefinition = (tagName, inputs, outputs, methods, inc
     }
     const propertyDeclarations = inlineComponentProps.map((m) => createPropertyDeclaration(m, `Components.${tagNameAsPascal}['${m.name}']`, true));
     const propertiesDeclarationText = [`protected el: HTML${tagNameAsPascal}Element;`, ...propertyDeclarations].join('\n  ');
+    const outputEvents = [];
+    if (hasOutputs) {
+        for (let compilerEvent of outputs) {
+            outputEvents.push(`  ${createAngularOutputDecorator(tagName, compilerEvent)}`);
+        }
+    }
     /**
      * Notes on the generated output:
      * - We disable @angular-eslint/no-inputs-metadata-property, so that
@@ -222,9 +228,10 @@ const createAngularComponentDefinition = (tagName, inputs, outputs, methods, inc
   changeDetection: ChangeDetectionStrategy.OnPush,
   template: '<ng-content></ng-content>',
   // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
-  inputs: [${formattedInputs}],${standaloneOption}
+  inputs: [${formattedInputs}],outputs:[${formattedOutputs}],${standaloneOption}
 })
 export class ${tagNameAsPascal} {
+  ${outputEvents.join('\n')}
   ${propertiesDeclarationText}
   constructor(c: ChangeDetectorRef, r: ElementRef, protected z: NgZone) {
     c.detach();
@@ -236,6 +243,22 @@ export class ${tagNameAsPascal} {
 }`;
     return output;
 };
+/**
+ * Creates an `@Output()` decorator for a custom event on a Stencil component.
+ * @param tagName The tag name of the component.
+ * @param event The Stencil component event.
+ * @returns The `@Output()` decorator as a string.
+ */
+const createAngularOutputDecorator = (tagName, event) => {
+    const tagNameAsPascal = dashToPascalCase(tagName);
+    // When updating to Stencil 3.0, the component custom event generic will be
+    // exported by default and can be referenced here with:
+    // const customEvent = `${tagNameAsPascal}CustomEvent`;
+    const customEventType = `CustomEvent`;
+    const eventType = formatOutputType(tagNameAsPascal, event);
+    const outputType = `${customEventType}<${eventType}>`;
+    return `@Output() ${event.name}: EventEmitter<${outputType}> = new EventEmitter();`;
+};
 /**
  * Sanitizes and formats the component event type.
  * @param componentClassName The class name of the component (e.g. 'MyComponent')
@@ -252,47 +275,47 @@ const formatOutputType = (componentClassName, event) => {
     return Object.entries(event.complexType.references)
         .filter(([_, refObject]) => refObject.location === 'local' || refObject.location === 'import')
         .reduce((type, [src, dst]) => {
-        let renamedType = type;
-        if (!type.startsWith(prefix)) {
-            if (type.startsWith('{') && type.endsWith('}')) {
-                /**
-                 * If the type starts with { and ends with }, it is an inline type.
-                 * For example, `{ a: string }`.
-                 * We don't need to rename these types, so we return the original type.
-                 */
-                renamedType = type;
-            }
-            else {
-                /**
-                 * If the type does not start with { and end with }, it is a reference type.
-                 * For example, `MyType`.
-                 * We need to rename these types, so we prepend the prefix.
-                 */
-                renamedType = `I${componentClassName}${type}`;
-            }
-        }
-        return (renamedType
-            .replace(new RegExp(`^${src}$`, 'g'), `${dst}`)
-            // Capture all instances of the `src` field surrounded by non-word characters on each side and join them.
-            .replace(new RegExp(`([^\\w])${src}([^\\w])`, 'g'), (v, p1, p2) => {
-            if ((dst === null || dst === void 0 ? void 0 : dst.location) === 'import') {
-                /**
-                 * Replaces a complex type reference within a generic type.
-                 * For example, remapping a type like `EventEmitter<CustomEvent<MyEvent<T>>>` to
-                 * `EventEmitter<CustomEvent<IMyComponentMyEvent<IMyComponentT>>>`.
-                 */
-                return [p1, `I${componentClassName}${v.substring(1, v.length - 1)}`, p2].join('');
+            let renamedType = type;
+            if (!type.startsWith(prefix)) {
+                if (type.startsWith('{') && type.endsWith('}')) {
+                    /**
+                     * If the type starts with { and ends with }, it is an inline type.
+                     * For example, `{ a: string }`.
+                     * We don't need to rename these types, so we return the original type.
+                     */
+                    renamedType = type;
+                }
+                else {
+                    /**
+                     * If the type does not start with { and end with }, it is a reference type.
+                     * For example, `MyType`.
+                     * We need to rename these types, so we prepend the prefix.
+                     */
+                    renamedType = `I${componentClassName}${type}`;
+                }
             }
-            return [p1, dst, p2].join('');
-        })
-            // Capture all instances that contain sub types, e.g. `IMyComponent.SomeMoreComplexType.SubType`.
-            .replace(new RegExp(`^${src}(\.\\w+)+$`, 'g'), (type) => {
-            return `I${componentClassName}${src}.${type.split('.').slice(1).join('.')}`;
-        }));
-    }, event.complexType.original
-        .replace(/\n/g, ' ')
-        .replace(/\s{2,}/g, ' ')
-        .replace(/,\s*/g, ', '));
+            return (renamedType
+                .replace(new RegExp(`^${src}$`, 'g'), `${dst}`)
+                // Capture all instances of the `src` field surrounded by non-word characters on each side and join them.
+                .replace(new RegExp(`([^\\w])${src}([^\\w])`, 'g'), (v, p1, p2) => {
+                    if ((dst === null || dst === void 0 ? void 0 : dst.location) === 'import') {
+                        /**
+                         * Replaces a complex type reference within a generic type.
+                         * For example, remapping a type like `EventEmitter<CustomEvent<MyEvent<T>>>` to
+                         * `EventEmitter<CustomEvent<IMyComponentMyEvent<IMyComponentT>>>`.
+                         */
+                        return [p1, `I${componentClassName}${v.substring(1, v.length - 1)}`, p2].join('');
+                    }
+                    return [p1, dst, p2].join('');
+                })
+                // Capture all instances that contain sub types, e.g. `IMyComponent.SomeMoreComplexType.SubType`.
+                .replace(new RegExp(`^${src}(\.\\w+)+$`, 'g'), (type) => {
+                    return `I${componentClassName}${src}.${type.split('.').slice(1).join('.')}`;
+                }));
+        }, event.complexType.original
+            .replace(/\n/g, ' ')
+            .replace(/\s{2,}/g, ' ')
+            .replace(/,\s*/g, ', '));
 };
 /**
  * Creates a formatted comment block based on the JS doc comment.
@@ -472,7 +495,7 @@ function generateProxies(components, pkgData, outputTarget, rootDir) {
     /**
      * The collection of named imports from @angular/core.
      */
-    const angularCoreImports = ['ChangeDetectionStrategy', 'ChangeDetectorRef', 'Component', 'ElementRef'];
+    const angularCoreImports = ['ChangeDetectionStrategy', 'ChangeDetectorRef', 'Component', 'ElementRef', 'Output'];
     if (includeOutputImports) {
         angularCoreImports.push('EventEmitter');
     }
@@ -550,7 +573,7 @@ ${createImportStatement(componentLibImports, './angular-component-lib/utils')}\n
          * 2. Optionally the @NgModule decorated class (if includeSingleComponentAngularModules is true)
          * 3. The component interface (using declaration merging for types).
          */
-        const componentDefinition = createAngularComponentDefinition(cmpMeta.tagName, inputs, outputs, methods, isCustomElementsBuild, isStandaloneBuild, inlineComponentProps);
+        const componentDefinition = createAngularComponentDefinition(cmpMeta.tagName, inputs, cmpMeta.events.filter(filterInternalProps), methods, isCustomElementsBuild, isStandaloneBuild, inlineComponentProps);
         const moduleDefinition = generateAngularModuleForComponent(cmpMeta.tagName);
         const componentTypeDefinition = createComponentTypeDefinition(outputType, tagNameAsPascal, cmpMeta.events, componentCorePackage, customElementsDir);
         proxyFileOutput.push(componentDefinition, '\n');
