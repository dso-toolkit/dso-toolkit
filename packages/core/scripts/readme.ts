/* eslint-disable @typescript-eslint/no-explicit-any -- For now quick and dirty, sorry. /Th */
import { readFile, writeFile } from "fs/promises";
import { dirname, join } from "path";

import { ComponentCompilerReferencedType } from "@stencil/core/internal";
import { watch } from "chokidar";
import * as prettier from "prettier";

const AUTO_GENERATED_TOOLKIT = "<!-- Auto Generated dso-toolkit -->";
const AUTO_GENERATED_BELOW = "<!-- Auto Generated Below -->";

interface MappedComponentCompilerReferencedType {
  name: string;
  id: string;
  referencedType: ComponentCompilerReferencedType;
}

(async (watchMode: boolean) => {
  console.info(`Running readme script in ${watchMode ? "watch" : "one-time"} mode...`);

  if (watchMode) {
    watch("docs.json", { persistent: true, ignoreInitial: true }).on("change", async () => {
      console.info("docs.json changed, updating readme files...");

      const docs = await readDocsJson();
      if (!docs) {
        // During Stencil compilation, the docs.json file is sometimes empty. This is only a problem during watch mode,
        // as the stenciler compiler will create a new docs.json file after the compilation is done.
        return;
      }

      await updateReadme(docs);
    });
  } else {
    console.info("Updating readme files...");

    const docs = await readDocsJson();
    if (!docs) {
      throw new Error("docs.json is empty or does not exist. Please run the Stencil compiler first.");
    }

    await updateReadme(docs);
  }
})(process.argv.includes("--watch"));

async function readDocsJson() {
  const json = (await readFile("docs.json", { encoding: "utf-8" })).trim();
  if (!json) {
    return null;
  }

  return JSON.parse(json);
}

async function updateReadme(docs: any) {
  for (const component of docs.components) {
    const readmePath = join(dirname(component.filePath), "readme.md");

    const types = getReferencesFromComponent(component)
      .reduce<MappedComponentCompilerReferencedType[]>((t, reference) => {
        const type = docs.typeLibrary[reference.id];

        if (type) {
          t.push({
            name: reference.name,
            id: reference.id,
            referencedType: type,
          });
        }

        return t;
      }, [])
      .sort((a, b) => a.name.localeCompare(b.name));

    const toolkitReadme = types.length > 0 ? `${AUTO_GENERATED_TOOLKIT}\n\n${printTypes(types)}\n\n` : "";

    const readme = await readFile(readmePath, { encoding: "utf-8" });

    const { manual, autoGenerated } = splitReadme(readme);

    const options = await prettier.resolveConfig(readmePath);
    if (!options) {
      throw new Error("No Prettier options");
    }

    options.filepath = readmePath;

    const newReadme = await prettier.format(`${manual.trimEnd()}\n\n${toolkitReadme}${autoGenerated}`, options);

    await writeFile(readmePath, newReadme, { encoding: "utf-8" });
  }

  function getReferencesFromComponent(component: any): Array<{ id: string; name: string }> {
    return [...component.events, ...component.props]
      .map((prop) => prop.complexType?.references)
      .flatMap((references) => Object.entries<any>(references))
      .reduce<ReturnType<typeof getReferencesFromComponent>>((t, [name, reference]) => {
        if (
          reference.location === "import" &&
          !reference.location.includes("node_modules") &&
          t.every(({ id }) => id !== reference.id)
        ) {
          t.push({ name, id: reference.id });
        }

        return t;
      }, []);
  }

  function printTypes(types: MappedComponentCompilerReferencedType[]): string {
    return [
      "## Types",
      "",
      ...types.map(
        (type) =>
          `### ${type.name}${
            type.referencedType.docstring && `\n\n${type.referencedType.docstring}`
          }\n\n\`\`\`typescript\n${type.referencedType.declaration}\n\`\`\`\n\n<!-- ${type.id} -->\n`,
      ),
    ]
      .join("\n")
      .trim();
  }

  function splitReadme(readme: string): { manual: string; autoGenerated: string } {
    const autoGeneratedToolkitIndex = readme.indexOf(AUTO_GENERATED_TOOLKIT);
    const autoGeneratedIndex = readme.indexOf(AUTO_GENERATED_BELOW);

    let endOfManualIndex = autoGeneratedToolkitIndex;
    if (endOfManualIndex === -1) {
      endOfManualIndex = autoGeneratedIndex;
    }

    if (endOfManualIndex === -1) {
      endOfManualIndex = readme.length;
    }

    const manual = readme.substring(0, endOfManualIndex);

    const autoGenerated = autoGeneratedIndex > -1 ? readme.substring(autoGeneratedIndex) : "";

    return {
      manual,
      autoGenerated,
    };
  }
}
