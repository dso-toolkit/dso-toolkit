diff --git a/node_modules/@stencil/angular-output-target/angular-component-lib/utils.ts b/node_modules/@stencil/angular-output-target/angular-component-lib/utils.ts
index d6cf7bd..b77e640 100644
--- a/node_modules/@stencil/angular-output-target/angular-component-lib/utils.ts
+++ b/node_modules/@stencil/angular-output-target/angular-component-lib/utils.ts
@@ -4,46 +4,62 @@ import { fromEvent } from 'rxjs';
 
 export const proxyInputs = (Cmp: any, inputs: string[]) => {
   const Prototype = Cmp.prototype;
-  inputs.forEach(item => {
+  inputs.forEach((item) => {
     Object.defineProperty(Prototype, item, {
       get() {
         return this.el[item];
       },
       set(val: any) {
         this.z.runOutsideAngular(() => (this.el[item] = val));
-      }
+      },
     });
   });
 };
 
 export const proxyMethods = (Cmp: any, methods: string[]) => {
   const Prototype = Cmp.prototype;
-  methods.forEach(methodName => {
+  methods.forEach((methodName) => {
     Prototype[methodName] = function () {
       const args = arguments;
-      return this.z.runOutsideAngular(() =>
-        this.el[methodName].apply(this.el, args)
-      );
+      return this.z.runOutsideAngular(() => this.el[methodName].apply(this.el, args));
     };
   });
 };
 
 export const proxyOutputs = (instance: any, el: any, events: string[]) => {
-  events.forEach(eventName => instance[eventName] = fromEvent(el, eventName));
-}
+  events.forEach((eventName) => (instance[eventName] = fromEvent(el, eventName)));
+};
 
 export const defineCustomElement = (tagName: string, customElement: any) => {
-  if (
-    customElement !== undefined &&
-    typeof customElements !== 'undefined' &&
-    !customElements.get(tagName)
-  ) {
+  if (customElement !== undefined && typeof customElements !== 'undefined' && !customElements.get(tagName)) {
     customElements.define(tagName, customElement);
   }
-}
+};
+
+/**
+ * The Angular property name that contains the object of metadata properties
+ * for the component added by the Angular compiler.
+ */
+const NG_COMP_DEF = 'ɵcmp';
+
+export const clearAngularOutputBindings = (cls: any) => {
+  if (typeof cls === 'function' && cls !== null) {
+    if (cls.prototype.constructor) {
+      const instance = cls.prototype.constructor;
+      if (instance[NG_COMP_DEF]) {
+        /**
+         * With the output targets generating @Output() proxies, we need to
+         * clear the metadata (ɵcmp.outputs) so that Angular does not add its own event listener
+         * and cause duplicate event emissions for the web component events.
+         */
+        instance[NG_COMP_DEF].outputs = {};
+      }
+    }
+  }
+};
 
 // tslint:disable-next-line: only-arrow-functions
-export function ProxyCmp(opts: { defineCustomElementFn?: () => void, inputs?: any; methods?: any }) {
+export function ProxyCmp(opts: { defineCustomElementFn?: () => void; inputs?: any; methods?: any }) {
   const decorator = function (cls: any) {
     const { defineCustomElementFn, inputs, methods } = opts;
 
@@ -51,6 +67,8 @@ export function ProxyCmp(opts: { defineCustomElementFn?: () => void, inputs?: an
       defineCustomElementFn();
     }
 
+    clearAngularOutputBindings(cls);
+
     if (inputs) {
       proxyInputs(cls, inputs);
     }
diff --git a/node_modules/@stencil/angular-output-target/dist/generate-angular-component.d.ts b/node_modules/@stencil/angular-output-target/dist/generate-angular-component.d.ts
index 9c74c66..a6bfe59 100644
--- a/node_modules/@stencil/angular-output-target/dist/generate-angular-component.d.ts
+++ b/node_modules/@stencil/angular-output-target/dist/generate-angular-component.d.ts
@@ -1,2 +1,22 @@
-import type { ComponentCompilerMeta } from '@stencil/core/internal';
-export declare const createComponentDefinition: (componentCorePackage: string, distTypesDir: string, rootDir: string, includeImportCustomElements?: boolean, customElementsDir?: string) => (cmpMeta: ComponentCompilerMeta) => string;
+import type { ComponentCompilerEvent } from '@stencil/core/internal';
+/**
+ * Creates an Angular component declaration from formatted Stencil compiler metadata.
+ *
+ * @param tagName The tag name of the component.
+ * @param inputs The inputs of the Stencil component (e.g. ['myInput']).
+ * @param outputs The outputs/events of the Stencil component. (e.g. ['myOutput']).
+ * @param methods The methods of the Stencil component. (e.g. ['myMethod']).
+ * @param includeImportCustomElements Whether to define the component as a custom element.
+ * @returns The component declaration as a string.
+ */
+export declare const createAngularComponentDefinition: (tagName: string, inputs: readonly string[], outputs: readonly ComponentCompilerEvent[], methods: readonly string[], includeImportCustomElements?: boolean) => string;
+/**
+ * Creates the component interface type definition.
+ * @param tagNameAsPascal The tag name as PascalCase.
+ * @param events The events to generate the interface properties for.
+ * @param componentCorePackage The component core package.
+ * @param includeImportCustomElements Whether to include the import for the custom element definition.
+ * @param customElementsDir The custom elements directory.
+ * @returns The component interface type definition as a string.
+ */
+export declare const createComponentTypeDefinition: (tagNameAsPascal: string, events: readonly ComponentCompilerEvent[], componentCorePackage: string, includeImportCustomElements?: boolean, customElementsDir?: string | undefined) => string;
diff --git a/node_modules/@stencil/angular-output-target/dist/generate-angular-component.js b/node_modules/@stencil/angular-output-target/dist/generate-angular-component.js
index 09c7d3a..1238ffd 100644
--- a/node_modules/@stencil/angular-output-target/dist/generate-angular-component.js
+++ b/node_modules/@stencil/angular-output-target/dist/generate-angular-component.js
@@ -1,101 +1,156 @@
-import { dashToPascalCase, normalizePath } from './utils';
-export const createComponentDefinition = (componentCorePackage, distTypesDir, rootDir, includeImportCustomElements = false, customElementsDir = 'components') => (cmpMeta) => {
-    // Collect component meta
-    const inputs = [
-        ...cmpMeta.properties.filter((prop) => !prop.internal).map((prop) => prop.name),
-        ...cmpMeta.virtualProperties.map((prop) => prop.name),
-    ].sort();
-    const outputs = cmpMeta.events.filter((ev) => !ev.internal).map((prop) => prop);
-    const methods = cmpMeta.methods.filter((method) => !method.internal).map((prop) => prop.name);
-    // Process meta
+import { createComponentEventTypeImports, dashToPascalCase, formatToQuotedList } from './utils';
+/**
+ * Creates an Angular component declaration from formatted Stencil compiler metadata.
+ *
+ * @param tagName The tag name of the component.
+ * @param inputs The inputs of the Stencil component (e.g. ['myInput']).
+ * @param outputs The outputs/events of the Stencil component. (e.g. ['myOutput']).
+ * @param methods The methods of the Stencil component. (e.g. ['myMethod']).
+ * @param includeImportCustomElements Whether to define the component as a custom element.
+ * @returns The component declaration as a string.
+ */
+export const createAngularComponentDefinition = (tagName, inputs, outputs, methods, includeImportCustomElements = false) => {
+    const tagNameAsPascal = dashToPascalCase(tagName);
+    const hasInputs = inputs.length > 0;
     const hasOutputs = outputs.length > 0;
-    // Generate Angular @Directive
-    const directiveOpts = [
-        `selector: \'${cmpMeta.tagName}\'`,
-        `changeDetection: ChangeDetectionStrategy.OnPush`,
-        `template: '<ng-content></ng-content>'`,
-    ];
-    if (inputs.length > 0) {
-        directiveOpts.push(`inputs: ['${inputs.join(`', '`)}']`);
+    const hasMethods = methods.length > 0;
+    // Formats the input strings into comma separated, single quoted values.
+    const formattedInputs = formatToQuotedList(inputs);
+    // Formats the output strings into comma separated, single quoted values.
+    const formattedOutputs = formatToQuotedList(outputs.map((event) => event.name));
+    // Formats the method strings into comma separated, single quoted values.
+    const formattedMethods = formatToQuotedList(methods);
+    const proxyCmpOptions = [];
+    if (includeImportCustomElements) {
+        const defineCustomElementFn = `define${tagNameAsPascal}`;
+        proxyCmpOptions.push(`\n  defineCustomElementFn: ${defineCustomElementFn}`);
     }
-    const tagNameAsPascal = dashToPascalCase(cmpMeta.tagName);
-    const outputsInterface = new Set();
-    const outputReferenceRemap = {};
-    outputs.forEach((output) => {
-        Object.entries(output.complexType.references).forEach(([reference, refObject]) => {
-            // Add import line for each local/import reference, and add new mapping name.
-            // `outputReferenceRemap` should be updated only if the import interface is set in outputsInterface,
-            // this will prevent global types to be remapped.
-            const remappedReference = `I${cmpMeta.componentClassName}${reference}`;
-            if (refObject.location === 'local' || refObject.location === 'import') {
-                outputReferenceRemap[reference] = remappedReference;
-                let importLocation = componentCorePackage;
-                if (componentCorePackage !== undefined) {
-                    const dirPath = includeImportCustomElements ? `/${customElementsDir || 'components'}` : '';
-                    importLocation = `${normalizePath(componentCorePackage)}${dirPath}`;
-                }
-                outputsInterface.add(`import type { ${reference} as ${remappedReference} } from '${importLocation}';`);
-            }
-        });
-    });
-    const componentEvents = [
-        '' // Empty first line
-    ];
-    // Generate outputs
-    outputs.forEach((output, index) => {
-        componentEvents.push(`  /**
-   * ${output.docs.text} ${output.docs.tags.map((tag) => `@${tag.name} ${tag.text}`)}
-   */`);
+    if (hasInputs) {
+        proxyCmpOptions.push(`\n  inputs: [${formattedInputs}]`);
+    }
+    if (hasMethods) {
+        proxyCmpOptions.push(`\n  methods: [${formattedMethods}]`);
+    }
+    const output = [
+        `@ProxyCmp({${proxyCmpOptions.join(',')}\n})`,
+        `@Component({`,
+        `  selector: '${tagName}',`,
+        `  changeDetection: ChangeDetectionStrategy.OnPush,`,
+        `  template: '<ng-content></ng-content>',`,
         /**
-         * The original attribute contains the original type defined by the devs.
-         * This regexp normalizes the reference, by removing linebreaks,
-         * replacing consecutive spaces with a single space, and adding a single space after commas.
-         **/
-        const outputTypeRemapped = Object.entries(outputReferenceRemap).reduce((type, [src, dst]) => {
-            return type
-                .replace(new RegExp(`^${src}$`, 'g'), `${dst}`)
-                .replace(new RegExp(`([^\\w])${src}([^\\w])`, 'g'), (v, p1, p2) => [p1, dst, p2].join(''));
-        }, output.complexType.original
-            .replace(/\n/g, ' ')
-            .replace(/\s{2,}/g, ' ')
-            .replace(/,\s*/g, ', '));
-        componentEvents.push(`  ${output.name}: EventEmitter<CustomEvent<${outputTypeRemapped.trim()}>>;`);
-        if (index === outputs.length - 1) {
-            // Empty line to push end `}` to new line
-            componentEvents.push('\n');
-        }
-    });
-    const lines = [
-        '',
-        `${[...outputsInterface].join('\n')}
-export declare interface ${tagNameAsPascal} extends Components.${tagNameAsPascal} {${componentEvents.length > 1 ? componentEvents.join('\n') : ''}}
-
-${getProxyCmp(cmpMeta.tagName, includeImportCustomElements, inputs, methods)}
-@Component({
-  ${directiveOpts.join(',\n  ')}
-})
-export class ${tagNameAsPascal} {`,
+         * We disable @angular-eslint/no-inputs-metadata-property, so that
+         * Angular does not complain about the inputs property. The output target
+         * uses the inputs property to define the inputs of the component instead of
+         * having to use the @Input decorator (and manually define the type and default value).
+         */
+        `  // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property`,
+        `  inputs: [${formattedInputs}],`,
+        `})`,
+        `export class ${tagNameAsPascal} {`,
     ];
-    lines.push('  protected el: HTMLElement;');
-    lines.push(`  constructor(c: ChangeDetectorRef, r: ElementRef, protected z: NgZone) {
-    c.detach();
-    this.el = r.nativeElement;`);
     if (hasOutputs) {
-        lines.push(`    proxyOutputs(this, this.el, ['${outputs.map((output) => output.name).join(`', '`)}']);`);
+        for (let compilerEvent of outputs) {
+            output.push(`  ${createAngularOutputDecorator(tagName, compilerEvent)}`);
+        }
+    }
+    output.push(`  protected el: HTMLElement;`);
+    output.push(`  constructor(c: ChangeDetectorRef, r: ElementRef, protected z: NgZone) {`);
+    output.push(`    c.detach();`);
+    output.push(`    this.el = r.nativeElement;`);
+    if (hasOutputs) {
+        output.push(`    proxyOutputs(this, this.el, [${formattedOutputs}]);`);
     }
-    lines.push(`  }`);
-    lines.push(`}`);
-    return lines.join('\n');
+    output.push(`  }`);
+    output.push(`}`);
+    return output.join('\n');
+};
+/**
+ * Creates an `@Output()` decorator for a custom event on a Stencil component.
+ * @param tagName The tag name of the component.
+ * @param event The Stencil component event.
+ * @returns The `@Output()` decorator as a string.
+ */
+const createAngularOutputDecorator = (tagName, event) => {
+    const tagNameAsPascal = dashToPascalCase(tagName);
+    // When updating to Stencil 3.0, the component custom event generic will be
+    // exported by default and can be referenced here with:
+    // const customEvent = `${tagNameAsPascal}CustomEvent`;
+    const customEventType = `CustomEvent`;
+    const eventType = formatOutputType(tagNameAsPascal, event);
+    const outputType = `${customEventType}<${eventType}>`;
+    return `@Output() ${event.name}: EventEmitter<${outputType}> = new EventEmitter();`;
+};
+/**
+ * Sanitizes and formats the component event type.
+ * @param componentClassName The class name of the component (e.g. 'MyComponent')
+ * @param event The Stencil component event.
+ * @returns The sanitized event type as a string.
+ */
+const formatOutputType = (componentClassName, event) => {
+    /**
+     * The original attribute contains the original type defined by the devs.
+     * This regexp normalizes the reference, by removing linebreaks,
+     * replacing consecutive spaces with a single space, and adding a single space after commas.
+     */
+    return Object.entries(event.complexType.references)
+        .filter(([_, refObject]) => refObject.location === 'local' || refObject.location === 'import')
+        .reduce((type, [src, dst]) => {
+        const renamedType = `I${componentClassName}${type}`;
+        return (renamedType
+            .replace(new RegExp(`^${src}$`, 'g'), `${dst}`)
+            // Capture all instances of the `src` field surrounded by non-word characters on each side and join them.
+            .replace(new RegExp(`([^\\w])${src}([^\\w])`, 'g'), (v, p1, p2) => [p1, dst, p2].join('')));
+    }, event.complexType.original
+        .replace(/\n/g, ' ')
+        .replace(/\s{2,}/g, ' ')
+        .replace(/,\s*/g, ', '));
+};
+/**
+ * Creates a formatted comment block based on the JS doc comment.
+ * @param doc The compiler jsdoc.
+ * @returns The formatted comment block as a string.
+ */
+const createDocComment = (doc) => {
+    if (doc.text.trim().length === 0 && doc.tags.length === 0) {
+        return '';
+    }
+    return `/**
+   * ${doc.text}${doc.tags.length > 0 ? ' ' : ''}${doc.tags.map((tag) => `@${tag.name} ${tag.text}`)}
+   */`;
+};
+/**
+ * Creates the component interface type definition.
+ * @param tagNameAsPascal The tag name as PascalCase.
+ * @param events The events to generate the interface properties for.
+ * @param componentCorePackage The component core package.
+ * @param includeImportCustomElements Whether to include the import for the custom element definition.
+ * @param customElementsDir The custom elements directory.
+ * @returns The component interface type definition as a string.
+ */
+export const createComponentTypeDefinition = (tagNameAsPascal, events, componentCorePackage, includeImportCustomElements = false, customElementsDir) => {
+    const publicEvents = events.filter((ev) => !ev.internal);
+    const eventTypeImports = createComponentEventTypeImports(tagNameAsPascal, publicEvents, {
+        componentCorePackage,
+        includeImportCustomElements,
+        customElementsDir,
+    });
+    const eventTypes = publicEvents.map((event) => {
+        const comment = createDocComment(event.docs);
+        let eventName = event.name;
+        if (event.name.includes('-')) {
+            // If an event name includes a dash, we need to wrap it in quotes.
+            // https://github.com/ionic-team/stencil-ds-output-targets/issues/212
+            eventName = `'${event.name}'`;
+        }
+        return `${comment.length > 0 ? `  ${comment}` : ''}
+  ${eventName}: EventEmitter<CustomEvent<${formatOutputType(tagNameAsPascal, event)}>>;`;
+    });
+    const interfaceDeclaration = `export declare interface ${tagNameAsPascal} extends Components.${tagNameAsPascal} {`;
+    const typeDefinition = (eventTypeImports.length > 0 ? `${eventTypeImports + '\n\n'}` : '') +
+        `${interfaceDeclaration}${eventTypes.length === 0
+            ? '}'
+            : `
+${eventTypes.join('\n')}
+}`}`;
+    return typeDefinition;
 };
-function getProxyCmp(tagName, includeCustomElement, inputs, methods) {
-    const hasInputs = inputs.length > 0;
-    const hasMethods = methods.length > 0;
-    const proxMeta = [
-        `defineCustomElementFn: ${includeCustomElement ? 'define' + dashToPascalCase(tagName) : 'undefined'}`
-    ];
-    if (hasInputs)
-        proxMeta.push(`inputs: ['${inputs.join(`', '`)}']`);
-    if (hasMethods)
-        proxMeta.push(`methods: ['${methods.join(`', '`)}']`);
-    return `@ProxyCmp({\n  ${proxMeta.join(',\n  ')}\n})`;
-}
diff --git a/node_modules/@stencil/angular-output-target/dist/generate-value-accessors.js b/node_modules/@stencil/angular-output-target/dist/generate-value-accessors.js
index 03b5574..6619bd2 100644
--- a/node_modules/@stencil/angular-output-target/dist/generate-value-accessors.js
+++ b/node_modules/@stencil/angular-output-target/dist/generate-value-accessors.js
@@ -1,15 +1,12 @@
 import { EOL } from 'os';
 import path from 'path';
 export default async function generateValueAccessors(compilerCtx, components, outputTarget, config) {
-    if (!Array.isArray(outputTarget.valueAccessorConfigs) ||
-        outputTarget.valueAccessorConfigs.length === 0) {
+    if (!Array.isArray(outputTarget.valueAccessorConfigs) || outputTarget.valueAccessorConfigs.length === 0) {
         return;
     }
     const targetDir = path.dirname(outputTarget.directivesProxyFile);
     const normalizedValueAccessors = outputTarget.valueAccessorConfigs.reduce((allAccessors, va) => {
-        const elementSelectors = Array.isArray(va.elementSelectors)
-            ? va.elementSelectors
-            : [va.elementSelectors];
+        const elementSelectors = Array.isArray(va.elementSelectors) ? va.elementSelectors : [va.elementSelectors];
         const type = va.type;
         let allElementSelectors = [];
         let allEventTargets = [];
diff --git a/node_modules/@stencil/angular-output-target/dist/index.cjs.js b/node_modules/@stencil/angular-output-target/dist/index.cjs.js
index 2e1b936..3517a06 100644
--- a/node_modules/@stencil/angular-output-target/dist/index.cjs.js
+++ b/node_modules/@stencil/angular-output-target/dist/index.cjs.js
@@ -81,110 +81,210 @@ async function readPackageJson(config, rootDir) {
     }
     return pkgData;
 }
-const EXTENDED_PATH_REGEX = /^\\\\\?\\/;
-const NON_ASCII_REGEX = /[^\x00-\x80]+/;
-const SLASH_REGEX = /\\/g;
-
-const createComponentDefinition = (componentCorePackage, distTypesDir, rootDir, includeImportCustomElements = false, customElementsDir = 'components') => (cmpMeta) => {
-    // Collect component meta
-    const inputs = [
-        ...cmpMeta.properties.filter((prop) => !prop.internal).map((prop) => prop.name),
-        ...cmpMeta.virtualProperties.map((prop) => prop.name),
-    ].sort();
-    const outputs = cmpMeta.events.filter((ev) => !ev.internal).map((prop) => prop);
-    const methods = cmpMeta.methods.filter((method) => !method.internal).map((prop) => prop.name);
-    // Process meta
-    const hasOutputs = outputs.length > 0;
-    // Generate Angular @Directive
-    const directiveOpts = [
-        `selector: \'${cmpMeta.tagName}\'`,
-        `changeDetection: ChangeDetectionStrategy.OnPush`,
-        `template: '<ng-content></ng-content>'`,
-    ];
-    if (inputs.length > 0) {
-        directiveOpts.push(`inputs: ['${inputs.join(`', '`)}']`);
+/**
+ * Formats an array of strings to a string of quoted, comma separated values.
+ * @param list The list of unformatted strings to format
+ * @returns The formatted array of strings. (e.g. ['foo', 'bar']) => `'foo', 'bar'`
+ */
+const formatToQuotedList = (list) => list.map((item) => `'${item}'`).join(', ');
+/**
+ * Creates an import statement for a list of named imports from a module.
+ * @param imports The list of named imports.
+ * @param module The module to import from.
+ *
+ * @returns The import statement as a string.
+ */
+const createImportStatement = (imports, module) => {
+    if (imports.length === 0) {
+        return '';
     }
-    const tagNameAsPascal = dashToPascalCase(cmpMeta.tagName);
-    const outputsInterface = new Set();
-    const outputReferenceRemap = {};
-    outputs.forEach((output) => {
-        Object.entries(output.complexType.references).forEach(([reference, refObject]) => {
-            // Add import line for each local/import reference, and add new mapping name.
-            // `outputReferenceRemap` should be updated only if the import interface is set in outputsInterface,
-            // this will prevent global types to be remapped.
-            const remappedReference = `I${cmpMeta.componentClassName}${reference}`;
+    return `import { ${imports.join(', ')} } from '${module}';`;
+};
+/**
+ * Creates the collection of import statements for a component based on the component's events type dependencies.
+ * @param componentTagName The tag name of the component (pascal case).
+ * @param events The events compiler metadata.
+ * @param options The options for generating the import statements (e.g. whether to import from the custom elements directory).
+ * @returns The import statements as an array of strings.
+ */
+const createComponentEventTypeImports = (componentTagName, events, options) => {
+    const { componentCorePackage, includeImportCustomElements, customElementsDir } = options;
+    const imports = [];
+    const namedImports = new Set();
+    const importPathName = normalizePath(componentCorePackage) + (includeImportCustomElements ? `/${customElementsDir || 'components'}` : '');
+    events.forEach((event) => {
+        Object.entries(event.complexType.references).forEach(([typeName, refObject]) => {
             if (refObject.location === 'local' || refObject.location === 'import') {
-                outputReferenceRemap[reference] = remappedReference;
-                let importLocation = componentCorePackage;
-                if (componentCorePackage !== undefined) {
-                    const dirPath = includeImportCustomElements ? `/${customElementsDir || 'components'}` : '';
-                    importLocation = `${normalizePath(componentCorePackage)}${dirPath}`;
+                const newTypeName = `I${componentTagName}${typeName}`;
+                // Prevents duplicate imports for the same type.
+                if (!namedImports.has(newTypeName)) {
+                    imports.push(`import type { ${typeName} as ${newTypeName} } from '${importPathName}';`);
+                    namedImports.add(newTypeName);
                 }
-                outputsInterface.add(`import type { ${reference} as ${remappedReference} } from '${importLocation}';`);
             }
         });
     });
-    const componentEvents = [
-        '' // Empty first line
-    ];
-    // Generate outputs
-    outputs.forEach((output, index) => {
-        componentEvents.push(`  /**
-   * ${output.docs.text} ${output.docs.tags.map((tag) => `@${tag.name} ${tag.text}`)}
-   */`);
-        /**
-         * The original attribute contains the original type defined by the devs.
-         * This regexp normalizes the reference, by removing linebreaks,
-         * replacing consecutive spaces with a single space, and adding a single space after commas.
-         **/
-        const outputTypeRemapped = Object.entries(outputReferenceRemap).reduce((type, [src, dst]) => {
-            return type
-                .replace(new RegExp(`^${src}$`, 'g'), `${dst}`)
-                .replace(new RegExp(`([^\\w])${src}([^\\w])`, 'g'), (v, p1, p2) => [p1, dst, p2].join(''));
-        }, output.complexType.original
-            .replace(/\n/g, ' ')
-            .replace(/\s{2,}/g, ' ')
-            .replace(/,\s*/g, ', '));
-        componentEvents.push(`  ${output.name}: EventEmitter<CustomEvent<${outputTypeRemapped.trim()}>>;`);
-        if (index === outputs.length - 1) {
-            // Empty line to push end `}` to new line
-            componentEvents.push('\n');
-        }
-    });
-    const lines = [
-        '',
-        `${[...outputsInterface].join('\n')}
-export declare interface ${tagNameAsPascal} extends Components.${tagNameAsPascal} {${componentEvents.length > 1 ? componentEvents.join('\n') : ''}}
+    return imports.join('\n');
+};
+const EXTENDED_PATH_REGEX = /^\\\\\?\\/;
+const NON_ASCII_REGEX = /[^\x00-\x80]+/;
+const SLASH_REGEX = /\\/g;
 
-${getProxyCmp(cmpMeta.tagName, includeImportCustomElements, inputs, methods)}
-@Component({
-  ${directiveOpts.join(',\n  ')}
-})
-export class ${tagNameAsPascal} {`,
+/**
+ * Creates an Angular component declaration from formatted Stencil compiler metadata.
+ *
+ * @param tagName The tag name of the component.
+ * @param inputs The inputs of the Stencil component (e.g. ['myInput']).
+ * @param outputs The outputs/events of the Stencil component. (e.g. ['myOutput']).
+ * @param methods The methods of the Stencil component. (e.g. ['myMethod']).
+ * @param includeImportCustomElements Whether to define the component as a custom element.
+ * @returns The component declaration as a string.
+ */
+const createAngularComponentDefinition = (tagName, inputs, outputs, methods, includeImportCustomElements = false) => {
+    const tagNameAsPascal = dashToPascalCase(tagName);
+    const hasInputs = inputs.length > 0;
+    const hasOutputs = outputs.length > 0;
+    const hasMethods = methods.length > 0;
+    // Formats the input strings into comma separated, single quoted values.
+    const formattedInputs = formatToQuotedList(inputs);
+    // Formats the output strings into comma separated, single quoted values.
+    const formattedOutputs = formatToQuotedList(outputs.map((event) => event.name));
+    // Formats the method strings into comma separated, single quoted values.
+    const formattedMethods = formatToQuotedList(methods);
+    const proxyCmpOptions = [];
+    if (includeImportCustomElements) {
+        const defineCustomElementFn = `define${tagNameAsPascal}`;
+        proxyCmpOptions.push(`\n  defineCustomElementFn: ${defineCustomElementFn}`);
+    }
+    if (hasInputs) {
+        proxyCmpOptions.push(`\n  inputs: [${formattedInputs}]`);
+    }
+    if (hasMethods) {
+        proxyCmpOptions.push(`\n  methods: [${formattedMethods}]`);
+    }
+    const output = [
+        `@ProxyCmp({${proxyCmpOptions.join(',')}\n})`,
+        `@Component({`,
+        `  selector: '${tagName}',`,
+        `  changeDetection: ChangeDetectionStrategy.OnPush,`,
+        `  template: '<ng-content></ng-content>',`,
+        /**
+         * We disable @angular-eslint/no-inputs-metadata-property, so that
+         * Angular does not complain about the inputs property. The output target
+         * uses the inputs property to define the inputs of the component instead of
+         * having to use the @Input decorator (and manually define the type and default value).
+         */
+        `  // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property`,
+        `  inputs: [${formattedInputs}],`,
+        `})`,
+        `export class ${tagNameAsPascal} {`,
     ];
-    lines.push('  protected el: HTMLElement;');
-    lines.push(`  constructor(c: ChangeDetectorRef, r: ElementRef, protected z: NgZone) {
-    c.detach();
-    this.el = r.nativeElement;`);
     if (hasOutputs) {
-        lines.push(`    proxyOutputs(this, this.el, ['${outputs.map((output) => output.name).join(`', '`)}']);`);
+        for (let compilerEvent of outputs) {
+            output.push(`  ${createAngularOutputDecorator(tagName, compilerEvent)}`);
+        }
+    }
+    output.push(`  protected el: HTMLElement;`);
+    output.push(`  constructor(c: ChangeDetectorRef, r: ElementRef, protected z: NgZone) {`);
+    output.push(`    c.detach();`);
+    output.push(`    this.el = r.nativeElement;`);
+    if (hasOutputs) {
+        output.push(`    proxyOutputs(this, this.el, [${formattedOutputs}]);`);
     }
-    lines.push(`  }`);
-    lines.push(`}`);
-    return lines.join('\n');
+    output.push(`  }`);
+    output.push(`}`);
+    return output.join('\n');
+};
+/**
+ * Creates an `@Output()` decorator for a custom event on a Stencil component.
+ * @param tagName The tag name of the component.
+ * @param event The Stencil component event.
+ * @returns The `@Output()` decorator as a string.
+ */
+const createAngularOutputDecorator = (tagName, event) => {
+    const tagNameAsPascal = dashToPascalCase(tagName);
+    // When updating to Stencil 3.0, the component custom event generic will be
+    // exported by default and can be referenced here with:
+    // const customEvent = `${tagNameAsPascal}CustomEvent`;
+    const customEventType = `CustomEvent`;
+    const eventType = formatOutputType(tagNameAsPascal, event);
+    const outputType = `${customEventType}<${eventType}>`;
+    return `@Output() ${event.name}: EventEmitter<${outputType}> = new EventEmitter();`;
+};
+/**
+ * Sanitizes and formats the component event type.
+ * @param componentClassName The class name of the component (e.g. 'MyComponent')
+ * @param event The Stencil component event.
+ * @returns The sanitized event type as a string.
+ */
+const formatOutputType = (componentClassName, event) => {
+    /**
+     * The original attribute contains the original type defined by the devs.
+     * This regexp normalizes the reference, by removing linebreaks,
+     * replacing consecutive spaces with a single space, and adding a single space after commas.
+     */
+    return Object.entries(event.complexType.references)
+        .filter(([_, refObject]) => refObject.location === 'local' || refObject.location === 'import')
+        .reduce((type, [src, dst]) => {
+        const renamedType = `I${componentClassName}${type}`;
+        return (renamedType
+            .replace(new RegExp(`^${src}$`, 'g'), `${dst}`)
+            // Capture all instances of the `src` field surrounded by non-word characters on each side and join them.
+            .replace(new RegExp(`([^\\w])${src}([^\\w])`, 'g'), (v, p1, p2) => [p1, dst, p2].join('')));
+    }, event.complexType.original
+        .replace(/\n/g, ' ')
+        .replace(/\s{2,}/g, ' ')
+        .replace(/,\s*/g, ', '));
+};
+/**
+ * Creates a formatted comment block based on the JS doc comment.
+ * @param doc The compiler jsdoc.
+ * @returns The formatted comment block as a string.
+ */
+const createDocComment = (doc) => {
+    if (doc.text.trim().length === 0 && doc.tags.length === 0) {
+        return '';
+    }
+    return `/**
+   * ${doc.text}${doc.tags.length > 0 ? ' ' : ''}${doc.tags.map((tag) => `@${tag.name} ${tag.text}`)}
+   */`;
+};
+/**
+ * Creates the component interface type definition.
+ * @param tagNameAsPascal The tag name as PascalCase.
+ * @param events The events to generate the interface properties for.
+ * @param componentCorePackage The component core package.
+ * @param includeImportCustomElements Whether to include the import for the custom element definition.
+ * @param customElementsDir The custom elements directory.
+ * @returns The component interface type definition as a string.
+ */
+const createComponentTypeDefinition = (tagNameAsPascal, events, componentCorePackage, includeImportCustomElements = false, customElementsDir) => {
+    const publicEvents = events.filter((ev) => !ev.internal);
+    const eventTypeImports = createComponentEventTypeImports(tagNameAsPascal, publicEvents, {
+        componentCorePackage,
+        includeImportCustomElements,
+        customElementsDir,
+    });
+    const eventTypes = publicEvents.map((event) => {
+        const comment = createDocComment(event.docs);
+        let eventName = event.name;
+        if (event.name.includes('-')) {
+            // If an event name includes a dash, we need to wrap it in quotes.
+            // https://github.com/ionic-team/stencil-ds-output-targets/issues/212
+            eventName = `'${event.name}'`;
+        }
+        return `${comment.length > 0 ? `  ${comment}` : ''}
+  ${eventName}: EventEmitter<CustomEvent<${formatOutputType(tagNameAsPascal, event)}>>;`;
+    });
+    const interfaceDeclaration = `export declare interface ${tagNameAsPascal} extends Components.${tagNameAsPascal} {`;
+    const typeDefinition = (eventTypeImports.length > 0 ? `${eventTypeImports + '\n\n'}` : '') +
+        `${interfaceDeclaration}${eventTypes.length === 0
+            ? '}'
+            : `
+${eventTypes.join('\n')}
+}`}`;
+    return typeDefinition;
 };
-function getProxyCmp(tagName, includeCustomElement, inputs, methods) {
-    const hasInputs = inputs.length > 0;
-    const hasMethods = methods.length > 0;
-    const proxMeta = [
-        `defineCustomElementFn: ${includeCustomElement ? 'define' + dashToPascalCase(tagName) : 'undefined'}`
-    ];
-    if (hasInputs)
-        proxMeta.push(`inputs: ['${inputs.join(`', '`)}']`);
-    if (hasMethods)
-        proxMeta.push(`methods: ['${methods.join(`', '`)}']`);
-    return `@ProxyCmp({\n  ${proxMeta.join(',\n  ')}\n})`;
-}
 
 function generateAngularDirectivesFile(compilerCtx, components, outputTarget) {
     // Only create the file if it is defined in the stencil configuration
@@ -207,15 +307,12 @@ export const DIRECTIVES = [
 }
 
 async function generateValueAccessors(compilerCtx, components, outputTarget, config) {
-    if (!Array.isArray(outputTarget.valueAccessorConfigs) ||
-        outputTarget.valueAccessorConfigs.length === 0) {
+    if (!Array.isArray(outputTarget.valueAccessorConfigs) || outputTarget.valueAccessorConfigs.length === 0) {
         return;
     }
     const targetDir = path__default['default'].dirname(outputTarget.directivesProxyFile);
     const normalizedValueAccessors = outputTarget.valueAccessorConfigs.reduce((allAccessors, va) => {
-        const elementSelectors = Array.isArray(va.elementSelectors)
-            ? va.elementSelectors
-            : [va.elementSelectors];
+        const elementSelectors = Array.isArray(va.elementSelectors) ? va.elementSelectors : [va.elementSelectors];
         const type = va.type;
         let allElementSelectors = [];
         let allEventTargets = [];
@@ -298,10 +395,27 @@ function generateProxies(components, pkgData, outputTarget, rootDir) {
     const distTypesDir = path__default['default'].dirname(pkgData.types);
     const dtsFilePath = path__default['default'].join(rootDir, distTypesDir, GENERATED_DTS);
     const componentsTypeFile = relativeImport(outputTarget.directivesProxyFile, dtsFilePath, '.d.ts');
+    /**
+     * The collection of named imports from @angular/core.
+     */
+    const angularCoreImports = [
+        'ChangeDetectionStrategy',
+        'ChangeDetectorRef',
+        'Component',
+        'ElementRef',
+        'EventEmitter',
+        'NgZone',
+        'Output',
+    ];
+    /**
+     * The collection of named imports from the angular-component-lib/utils.
+     */
+    const componentLibImports = ['ProxyCmp', 'proxyOutputs'];
     const imports = `/* tslint:disable */
 /* auto-generated angular directive proxies */
-import { ChangeDetectionStrategy, ChangeDetectorRef, Component, ElementRef, EventEmitter, NgZone } from '@angular/core';
-import { ProxyCmp, proxyOutputs } from './angular-component-lib/utils';\n`;
+${createImportStatement(angularCoreImports, '@angular/core')}
+
+${createImportStatement(componentLibImports, './angular-component-lib/utils')}\n`;
     /**
      * Generate JSX import type from correct location.
      * When using custom elements build, we need to import from
@@ -309,8 +423,12 @@ import { ProxyCmp, proxyOutputs } from './angular-component-lib/utils';\n`;
      * otherwise we risk bundlers pulling in lazy loaded imports.
      */
     const generateTypeImports = () => {
-        let importLocation = outputTarget.componentCorePackage ? normalizePath(outputTarget.componentCorePackage) : normalizePath(componentsTypeFile);
-        importLocation += outputTarget.includeImportCustomElements ? `/${outputTarget.customElementsDir || 'components'}` : '';
+        let importLocation = outputTarget.componentCorePackage
+            ? normalizePath(outputTarget.componentCorePackage)
+            : normalizePath(componentsTypeFile);
+        importLocation += outputTarget.includeImportCustomElements
+            ? `/${outputTarget.customElementsDir || 'components'}`
+            : '';
         return `import ${outputTarget.includeImportCustomElements ? 'type ' : ''}{ ${IMPORT_TYPES} } from '${importLocation}';\n`;
     };
     const typeImports = generateTypeImports();
@@ -322,21 +440,45 @@ import { ProxyCmp, proxyOutputs } from './angular-component-lib/utils';\n`;
      * IonButton React Component that takes in the Web Component as a parameter.
      */
     if (outputTarget.includeImportCustomElements && outputTarget.componentCorePackage !== undefined) {
-        const cmpImports = components.map(component => {
+        const cmpImports = components.map((component) => {
             const pascalImport = dashToPascalCase(component.tagName);
-            return `import { defineCustomElement as define${pascalImport} } from '${normalizePath(outputTarget.componentCorePackage)}/${outputTarget.customElementsDir ||
-                'components'}/${component.tagName}.js';`;
+            return `import { defineCustomElement as define${pascalImport} } from '${normalizePath(outputTarget.componentCorePackage)}/${outputTarget.customElementsDir || 'components'}/${component.tagName}.js';`;
         });
         sourceImports = cmpImports.join('\n');
     }
-    const final = [
-        imports,
-        typeImports,
-        sourceImports,
-        components
-            .map(createComponentDefinition(outputTarget.componentCorePackage, distTypesDir, rootDir, outputTarget.includeImportCustomElements, outputTarget.customElementsDir))
-            .join('\n'),
-    ];
+    const proxyFileOutput = [];
+    const filterInternalProps = (prop) => !prop.internal;
+    const mapPropName = (prop) => prop.name;
+    const { includeImportCustomElements, componentCorePackage, customElementsDir } = outputTarget;
+    for (let cmpMeta of components) {
+        const tagNameAsPascal = dashToPascalCase(cmpMeta.tagName);
+        const inputs = [];
+        if (cmpMeta.properties) {
+            inputs.push(...cmpMeta.properties.filter(filterInternalProps).map(mapPropName));
+        }
+        if (cmpMeta.virtualProperties) {
+            inputs.push(...cmpMeta.virtualProperties.map(mapPropName));
+        }
+        inputs.sort();
+        const outputs = [];
+        if (cmpMeta.events) {
+            outputs.push(...cmpMeta.events.filter(filterInternalProps));
+        }
+        const methods = [];
+        if (cmpMeta.methods) {
+            methods.push(...cmpMeta.methods.filter(filterInternalProps).map(mapPropName));
+        }
+        /**
+         * For each component, we need to generate:
+         * 1. The @Component decorated class
+         * 2. The component interface (using declaration merging for types).
+         */
+        const componentDefinition = createAngularComponentDefinition(cmpMeta.tagName, inputs, outputs, methods, includeImportCustomElements);
+        const componentTypeDefinition = createComponentTypeDefinition(tagNameAsPascal, cmpMeta.events, componentCorePackage, includeImportCustomElements, customElementsDir);
+        proxyFileOutput.push(componentDefinition, '\n');
+        proxyFileOutput.push(componentTypeDefinition, '\n');
+    }
+    const final = [imports, typeImports, sourceImports, ...proxyFileOutput];
     return final.join('\n') + '\n';
 }
 const GENERATED_DTS = 'components.d.ts';
@@ -355,12 +497,12 @@ const angularOutputTarget = (outputTarget) => ({
     },
 });
 function normalizeOutputTarget(config, outputTarget) {
-    const results = Object.assign(Object.assign({}, outputTarget), { excludeComponents: outputTarget.excludeComponents || [], valueAccessorConfig: outputTarget.valueAccessorConfig || [] });
+    const results = Object.assign(Object.assign({}, outputTarget), { excludeComponents: outputTarget.excludeComponents || [], valueAccessorConfigs: outputTarget.valueAccessorConfigs || [] });
     if (config.rootDir == null) {
         throw new Error('rootDir is not set and it should be set by stencil itself');
     }
     if (outputTarget.directivesProxyFile == null) {
-        throw new Error('directivesProxyFile is required');
+        throw new Error('directivesProxyFile is required. Please set it in the Stencil config.');
     }
     if (outputTarget.directivesProxyFile && !path__default['default'].isAbsolute(outputTarget.directivesProxyFile)) {
         results.directivesProxyFile = normalizePath(path__default['default'].join(config.rootDir, outputTarget.directivesProxyFile));
@@ -368,9 +510,6 @@ function normalizeOutputTarget(config, outputTarget) {
     if (outputTarget.directivesArrayFile && !path__default['default'].isAbsolute(outputTarget.directivesArrayFile)) {
         results.directivesArrayFile = normalizePath(path__default['default'].join(config.rootDir, outputTarget.directivesArrayFile));
     }
-    if (outputTarget.directivesUtilsFile && !path__default['default'].isAbsolute(outputTarget.directivesUtilsFile)) {
-        results.directivesUtilsFile = normalizePath(path__default['default'].join(config.rootDir, outputTarget.directivesUtilsFile));
-    }
     return results;
 }
 
diff --git a/node_modules/@stencil/angular-output-target/dist/index.js b/node_modules/@stencil/angular-output-target/dist/index.js
index ba719be..96f3a1d 100644
--- a/node_modules/@stencil/angular-output-target/dist/index.js
+++ b/node_modules/@stencil/angular-output-target/dist/index.js
@@ -73,110 +73,210 @@ async function readPackageJson(config, rootDir) {
     }
     return pkgData;
 }
-const EXTENDED_PATH_REGEX = /^\\\\\?\\/;
-const NON_ASCII_REGEX = /[^\x00-\x80]+/;
-const SLASH_REGEX = /\\/g;
-
-const createComponentDefinition = (componentCorePackage, distTypesDir, rootDir, includeImportCustomElements = false, customElementsDir = 'components') => (cmpMeta) => {
-    // Collect component meta
-    const inputs = [
-        ...cmpMeta.properties.filter((prop) => !prop.internal).map((prop) => prop.name),
-        ...cmpMeta.virtualProperties.map((prop) => prop.name),
-    ].sort();
-    const outputs = cmpMeta.events.filter((ev) => !ev.internal).map((prop) => prop);
-    const methods = cmpMeta.methods.filter((method) => !method.internal).map((prop) => prop.name);
-    // Process meta
-    const hasOutputs = outputs.length > 0;
-    // Generate Angular @Directive
-    const directiveOpts = [
-        `selector: \'${cmpMeta.tagName}\'`,
-        `changeDetection: ChangeDetectionStrategy.OnPush`,
-        `template: '<ng-content></ng-content>'`,
-    ];
-    if (inputs.length > 0) {
-        directiveOpts.push(`inputs: ['${inputs.join(`', '`)}']`);
+/**
+ * Formats an array of strings to a string of quoted, comma separated values.
+ * @param list The list of unformatted strings to format
+ * @returns The formatted array of strings. (e.g. ['foo', 'bar']) => `'foo', 'bar'`
+ */
+const formatToQuotedList = (list) => list.map((item) => `'${item}'`).join(', ');
+/**
+ * Creates an import statement for a list of named imports from a module.
+ * @param imports The list of named imports.
+ * @param module The module to import from.
+ *
+ * @returns The import statement as a string.
+ */
+const createImportStatement = (imports, module) => {
+    if (imports.length === 0) {
+        return '';
     }
-    const tagNameAsPascal = dashToPascalCase(cmpMeta.tagName);
-    const outputsInterface = new Set();
-    const outputReferenceRemap = {};
-    outputs.forEach((output) => {
-        Object.entries(output.complexType.references).forEach(([reference, refObject]) => {
-            // Add import line for each local/import reference, and add new mapping name.
-            // `outputReferenceRemap` should be updated only if the import interface is set in outputsInterface,
-            // this will prevent global types to be remapped.
-            const remappedReference = `I${cmpMeta.componentClassName}${reference}`;
+    return `import { ${imports.join(', ')} } from '${module}';`;
+};
+/**
+ * Creates the collection of import statements for a component based on the component's events type dependencies.
+ * @param componentTagName The tag name of the component (pascal case).
+ * @param events The events compiler metadata.
+ * @param options The options for generating the import statements (e.g. whether to import from the custom elements directory).
+ * @returns The import statements as an array of strings.
+ */
+const createComponentEventTypeImports = (componentTagName, events, options) => {
+    const { componentCorePackage, includeImportCustomElements, customElementsDir } = options;
+    const imports = [];
+    const namedImports = new Set();
+    const importPathName = normalizePath(componentCorePackage) + (includeImportCustomElements ? `/${customElementsDir || 'components'}` : '');
+    events.forEach((event) => {
+        Object.entries(event.complexType.references).forEach(([typeName, refObject]) => {
             if (refObject.location === 'local' || refObject.location === 'import') {
-                outputReferenceRemap[reference] = remappedReference;
-                let importLocation = componentCorePackage;
-                if (componentCorePackage !== undefined) {
-                    const dirPath = includeImportCustomElements ? `/${customElementsDir || 'components'}` : '';
-                    importLocation = `${normalizePath(componentCorePackage)}${dirPath}`;
+                const newTypeName = `I${componentTagName}${typeName}`;
+                // Prevents duplicate imports for the same type.
+                if (!namedImports.has(newTypeName)) {
+                    imports.push(`import type { ${typeName} as ${newTypeName} } from '${importPathName}';`);
+                    namedImports.add(newTypeName);
                 }
-                outputsInterface.add(`import type { ${reference} as ${remappedReference} } from '${importLocation}';`);
             }
         });
     });
-    const componentEvents = [
-        '' // Empty first line
-    ];
-    // Generate outputs
-    outputs.forEach((output, index) => {
-        componentEvents.push(`  /**
-   * ${output.docs.text} ${output.docs.tags.map((tag) => `@${tag.name} ${tag.text}`)}
-   */`);
-        /**
-         * The original attribute contains the original type defined by the devs.
-         * This regexp normalizes the reference, by removing linebreaks,
-         * replacing consecutive spaces with a single space, and adding a single space after commas.
-         **/
-        const outputTypeRemapped = Object.entries(outputReferenceRemap).reduce((type, [src, dst]) => {
-            return type
-                .replace(new RegExp(`^${src}$`, 'g'), `${dst}`)
-                .replace(new RegExp(`([^\\w])${src}([^\\w])`, 'g'), (v, p1, p2) => [p1, dst, p2].join(''));
-        }, output.complexType.original
-            .replace(/\n/g, ' ')
-            .replace(/\s{2,}/g, ' ')
-            .replace(/,\s*/g, ', '));
-        componentEvents.push(`  ${output.name}: EventEmitter<CustomEvent<${outputTypeRemapped.trim()}>>;`);
-        if (index === outputs.length - 1) {
-            // Empty line to push end `}` to new line
-            componentEvents.push('\n');
-        }
-    });
-    const lines = [
-        '',
-        `${[...outputsInterface].join('\n')}
-export declare interface ${tagNameAsPascal} extends Components.${tagNameAsPascal} {${componentEvents.length > 1 ? componentEvents.join('\n') : ''}}
+    return imports.join('\n');
+};
+const EXTENDED_PATH_REGEX = /^\\\\\?\\/;
+const NON_ASCII_REGEX = /[^\x00-\x80]+/;
+const SLASH_REGEX = /\\/g;
 
-${getProxyCmp(cmpMeta.tagName, includeImportCustomElements, inputs, methods)}
-@Component({
-  ${directiveOpts.join(',\n  ')}
-})
-export class ${tagNameAsPascal} {`,
+/**
+ * Creates an Angular component declaration from formatted Stencil compiler metadata.
+ *
+ * @param tagName The tag name of the component.
+ * @param inputs The inputs of the Stencil component (e.g. ['myInput']).
+ * @param outputs The outputs/events of the Stencil component. (e.g. ['myOutput']).
+ * @param methods The methods of the Stencil component. (e.g. ['myMethod']).
+ * @param includeImportCustomElements Whether to define the component as a custom element.
+ * @returns The component declaration as a string.
+ */
+const createAngularComponentDefinition = (tagName, inputs, outputs, methods, includeImportCustomElements = false) => {
+    const tagNameAsPascal = dashToPascalCase(tagName);
+    const hasInputs = inputs.length > 0;
+    const hasOutputs = outputs.length > 0;
+    const hasMethods = methods.length > 0;
+    // Formats the input strings into comma separated, single quoted values.
+    const formattedInputs = formatToQuotedList(inputs);
+    // Formats the output strings into comma separated, single quoted values.
+    const formattedOutputs = formatToQuotedList(outputs.map((event) => event.name));
+    // Formats the method strings into comma separated, single quoted values.
+    const formattedMethods = formatToQuotedList(methods);
+    const proxyCmpOptions = [];
+    if (includeImportCustomElements) {
+        const defineCustomElementFn = `define${tagNameAsPascal}`;
+        proxyCmpOptions.push(`\n  defineCustomElementFn: ${defineCustomElementFn}`);
+    }
+    if (hasInputs) {
+        proxyCmpOptions.push(`\n  inputs: [${formattedInputs}]`);
+    }
+    if (hasMethods) {
+        proxyCmpOptions.push(`\n  methods: [${formattedMethods}]`);
+    }
+    const output = [
+        `@ProxyCmp({${proxyCmpOptions.join(',')}\n})`,
+        `@Component({`,
+        `  selector: '${tagName}',`,
+        `  changeDetection: ChangeDetectionStrategy.OnPush,`,
+        `  template: '<ng-content></ng-content>',`,
+        /**
+         * We disable @angular-eslint/no-inputs-metadata-property, so that
+         * Angular does not complain about the inputs property. The output target
+         * uses the inputs property to define the inputs of the component instead of
+         * having to use the @Input decorator (and manually define the type and default value).
+         */
+        `  // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property`,
+        `  inputs: [${formattedInputs}],`,
+        `})`,
+        `export class ${tagNameAsPascal} {`,
     ];
-    lines.push('  protected el: HTMLElement;');
-    lines.push(`  constructor(c: ChangeDetectorRef, r: ElementRef, protected z: NgZone) {
-    c.detach();
-    this.el = r.nativeElement;`);
     if (hasOutputs) {
-        lines.push(`    proxyOutputs(this, this.el, ['${outputs.map((output) => output.name).join(`', '`)}']);`);
+        for (let compilerEvent of outputs) {
+            output.push(`  ${createAngularOutputDecorator(tagName, compilerEvent)}`);
+        }
+    }
+    output.push(`  protected el: HTMLElement;`);
+    output.push(`  constructor(c: ChangeDetectorRef, r: ElementRef, protected z: NgZone) {`);
+    output.push(`    c.detach();`);
+    output.push(`    this.el = r.nativeElement;`);
+    if (hasOutputs) {
+        output.push(`    proxyOutputs(this, this.el, [${formattedOutputs}]);`);
     }
-    lines.push(`  }`);
-    lines.push(`}`);
-    return lines.join('\n');
+    output.push(`  }`);
+    output.push(`}`);
+    return output.join('\n');
+};
+/**
+ * Creates an `@Output()` decorator for a custom event on a Stencil component.
+ * @param tagName The tag name of the component.
+ * @param event The Stencil component event.
+ * @returns The `@Output()` decorator as a string.
+ */
+const createAngularOutputDecorator = (tagName, event) => {
+    const tagNameAsPascal = dashToPascalCase(tagName);
+    // When updating to Stencil 3.0, the component custom event generic will be
+    // exported by default and can be referenced here with:
+    // const customEvent = `${tagNameAsPascal}CustomEvent`;
+    const customEventType = `CustomEvent`;
+    const eventType = formatOutputType(tagNameAsPascal, event);
+    const outputType = `${customEventType}<${eventType}>`;
+    return `@Output() ${event.name}: EventEmitter<${outputType}> = new EventEmitter();`;
+};
+/**
+ * Sanitizes and formats the component event type.
+ * @param componentClassName The class name of the component (e.g. 'MyComponent')
+ * @param event The Stencil component event.
+ * @returns The sanitized event type as a string.
+ */
+const formatOutputType = (componentClassName, event) => {
+    /**
+     * The original attribute contains the original type defined by the devs.
+     * This regexp normalizes the reference, by removing linebreaks,
+     * replacing consecutive spaces with a single space, and adding a single space after commas.
+     */
+    return Object.entries(event.complexType.references)
+        .filter(([_, refObject]) => refObject.location === 'local' || refObject.location === 'import')
+        .reduce((type, [src, dst]) => {
+        const renamedType = `I${componentClassName}${type}`;
+        return (renamedType
+            .replace(new RegExp(`^${src}$`, 'g'), `${dst}`)
+            // Capture all instances of the `src` field surrounded by non-word characters on each side and join them.
+            .replace(new RegExp(`([^\\w])${src}([^\\w])`, 'g'), (v, p1, p2) => [p1, dst, p2].join('')));
+    }, event.complexType.original
+        .replace(/\n/g, ' ')
+        .replace(/\s{2,}/g, ' ')
+        .replace(/,\s*/g, ', '));
+};
+/**
+ * Creates a formatted comment block based on the JS doc comment.
+ * @param doc The compiler jsdoc.
+ * @returns The formatted comment block as a string.
+ */
+const createDocComment = (doc) => {
+    if (doc.text.trim().length === 0 && doc.tags.length === 0) {
+        return '';
+    }
+    return `/**
+   * ${doc.text}${doc.tags.length > 0 ? ' ' : ''}${doc.tags.map((tag) => `@${tag.name} ${tag.text}`)}
+   */`;
+};
+/**
+ * Creates the component interface type definition.
+ * @param tagNameAsPascal The tag name as PascalCase.
+ * @param events The events to generate the interface properties for.
+ * @param componentCorePackage The component core package.
+ * @param includeImportCustomElements Whether to include the import for the custom element definition.
+ * @param customElementsDir The custom elements directory.
+ * @returns The component interface type definition as a string.
+ */
+const createComponentTypeDefinition = (tagNameAsPascal, events, componentCorePackage, includeImportCustomElements = false, customElementsDir) => {
+    const publicEvents = events.filter((ev) => !ev.internal);
+    const eventTypeImports = createComponentEventTypeImports(tagNameAsPascal, publicEvents, {
+        componentCorePackage,
+        includeImportCustomElements,
+        customElementsDir,
+    });
+    const eventTypes = publicEvents.map((event) => {
+        const comment = createDocComment(event.docs);
+        let eventName = event.name;
+        if (event.name.includes('-')) {
+            // If an event name includes a dash, we need to wrap it in quotes.
+            // https://github.com/ionic-team/stencil-ds-output-targets/issues/212
+            eventName = `'${event.name}'`;
+        }
+        return `${comment.length > 0 ? `  ${comment}` : ''}
+  ${eventName}: EventEmitter<CustomEvent<${formatOutputType(tagNameAsPascal, event)}>>;`;
+    });
+    const interfaceDeclaration = `export declare interface ${tagNameAsPascal} extends Components.${tagNameAsPascal} {`;
+    const typeDefinition = (eventTypeImports.length > 0 ? `${eventTypeImports + '\n\n'}` : '') +
+        `${interfaceDeclaration}${eventTypes.length === 0
+            ? '}'
+            : `
+${eventTypes.join('\n')}
+}`}`;
+    return typeDefinition;
 };
-function getProxyCmp(tagName, includeCustomElement, inputs, methods) {
-    const hasInputs = inputs.length > 0;
-    const hasMethods = methods.length > 0;
-    const proxMeta = [
-        `defineCustomElementFn: ${includeCustomElement ? 'define' + dashToPascalCase(tagName) : 'undefined'}`
-    ];
-    if (hasInputs)
-        proxMeta.push(`inputs: ['${inputs.join(`', '`)}']`);
-    if (hasMethods)
-        proxMeta.push(`methods: ['${methods.join(`', '`)}']`);
-    return `@ProxyCmp({\n  ${proxMeta.join(',\n  ')}\n})`;
-}
 
 function generateAngularDirectivesFile(compilerCtx, components, outputTarget) {
     // Only create the file if it is defined in the stencil configuration
@@ -199,15 +299,12 @@ export const DIRECTIVES = [
 }
 
 async function generateValueAccessors(compilerCtx, components, outputTarget, config) {
-    if (!Array.isArray(outputTarget.valueAccessorConfigs) ||
-        outputTarget.valueAccessorConfigs.length === 0) {
+    if (!Array.isArray(outputTarget.valueAccessorConfigs) || outputTarget.valueAccessorConfigs.length === 0) {
         return;
     }
     const targetDir = path.dirname(outputTarget.directivesProxyFile);
     const normalizedValueAccessors = outputTarget.valueAccessorConfigs.reduce((allAccessors, va) => {
-        const elementSelectors = Array.isArray(va.elementSelectors)
-            ? va.elementSelectors
-            : [va.elementSelectors];
+        const elementSelectors = Array.isArray(va.elementSelectors) ? va.elementSelectors : [va.elementSelectors];
         const type = va.type;
         let allElementSelectors = [];
         let allEventTargets = [];
@@ -290,10 +387,27 @@ function generateProxies(components, pkgData, outputTarget, rootDir) {
     const distTypesDir = path.dirname(pkgData.types);
     const dtsFilePath = path.join(rootDir, distTypesDir, GENERATED_DTS);
     const componentsTypeFile = relativeImport(outputTarget.directivesProxyFile, dtsFilePath, '.d.ts');
+    /**
+     * The collection of named imports from @angular/core.
+     */
+    const angularCoreImports = [
+        'ChangeDetectionStrategy',
+        'ChangeDetectorRef',
+        'Component',
+        'ElementRef',
+        'EventEmitter',
+        'NgZone',
+        'Output',
+    ];
+    /**
+     * The collection of named imports from the angular-component-lib/utils.
+     */
+    const componentLibImports = ['ProxyCmp', 'proxyOutputs'];
     const imports = `/* tslint:disable */
 /* auto-generated angular directive proxies */
-import { ChangeDetectionStrategy, ChangeDetectorRef, Component, ElementRef, EventEmitter, NgZone } from '@angular/core';
-import { ProxyCmp, proxyOutputs } from './angular-component-lib/utils';\n`;
+${createImportStatement(angularCoreImports, '@angular/core')}
+
+${createImportStatement(componentLibImports, './angular-component-lib/utils')}\n`;
     /**
      * Generate JSX import type from correct location.
      * When using custom elements build, we need to import from
@@ -301,8 +415,12 @@ import { ProxyCmp, proxyOutputs } from './angular-component-lib/utils';\n`;
      * otherwise we risk bundlers pulling in lazy loaded imports.
      */
     const generateTypeImports = () => {
-        let importLocation = outputTarget.componentCorePackage ? normalizePath(outputTarget.componentCorePackage) : normalizePath(componentsTypeFile);
-        importLocation += outputTarget.includeImportCustomElements ? `/${outputTarget.customElementsDir || 'components'}` : '';
+        let importLocation = outputTarget.componentCorePackage
+            ? normalizePath(outputTarget.componentCorePackage)
+            : normalizePath(componentsTypeFile);
+        importLocation += outputTarget.includeImportCustomElements
+            ? `/${outputTarget.customElementsDir || 'components'}`
+            : '';
         return `import ${outputTarget.includeImportCustomElements ? 'type ' : ''}{ ${IMPORT_TYPES} } from '${importLocation}';\n`;
     };
     const typeImports = generateTypeImports();
@@ -314,21 +432,45 @@ import { ProxyCmp, proxyOutputs } from './angular-component-lib/utils';\n`;
      * IonButton React Component that takes in the Web Component as a parameter.
      */
     if (outputTarget.includeImportCustomElements && outputTarget.componentCorePackage !== undefined) {
-        const cmpImports = components.map(component => {
+        const cmpImports = components.map((component) => {
             const pascalImport = dashToPascalCase(component.tagName);
-            return `import { defineCustomElement as define${pascalImport} } from '${normalizePath(outputTarget.componentCorePackage)}/${outputTarget.customElementsDir ||
-                'components'}/${component.tagName}.js';`;
+            return `import { defineCustomElement as define${pascalImport} } from '${normalizePath(outputTarget.componentCorePackage)}/${outputTarget.customElementsDir || 'components'}/${component.tagName}.js';`;
         });
         sourceImports = cmpImports.join('\n');
     }
-    const final = [
-        imports,
-        typeImports,
-        sourceImports,
-        components
-            .map(createComponentDefinition(outputTarget.componentCorePackage, distTypesDir, rootDir, outputTarget.includeImportCustomElements, outputTarget.customElementsDir))
-            .join('\n'),
-    ];
+    const proxyFileOutput = [];
+    const filterInternalProps = (prop) => !prop.internal;
+    const mapPropName = (prop) => prop.name;
+    const { includeImportCustomElements, componentCorePackage, customElementsDir } = outputTarget;
+    for (let cmpMeta of components) {
+        const tagNameAsPascal = dashToPascalCase(cmpMeta.tagName);
+        const inputs = [];
+        if (cmpMeta.properties) {
+            inputs.push(...cmpMeta.properties.filter(filterInternalProps).map(mapPropName));
+        }
+        if (cmpMeta.virtualProperties) {
+            inputs.push(...cmpMeta.virtualProperties.map(mapPropName));
+        }
+        inputs.sort();
+        const outputs = [];
+        if (cmpMeta.events) {
+            outputs.push(...cmpMeta.events.filter(filterInternalProps));
+        }
+        const methods = [];
+        if (cmpMeta.methods) {
+            methods.push(...cmpMeta.methods.filter(filterInternalProps).map(mapPropName));
+        }
+        /**
+         * For each component, we need to generate:
+         * 1. The @Component decorated class
+         * 2. The component interface (using declaration merging for types).
+         */
+        const componentDefinition = createAngularComponentDefinition(cmpMeta.tagName, inputs, outputs, methods, includeImportCustomElements);
+        const componentTypeDefinition = createComponentTypeDefinition(tagNameAsPascal, cmpMeta.events, componentCorePackage, includeImportCustomElements, customElementsDir);
+        proxyFileOutput.push(componentDefinition, '\n');
+        proxyFileOutput.push(componentTypeDefinition, '\n');
+    }
+    const final = [imports, typeImports, sourceImports, ...proxyFileOutput];
     return final.join('\n') + '\n';
 }
 const GENERATED_DTS = 'components.d.ts';
@@ -347,12 +489,12 @@ const angularOutputTarget = (outputTarget) => ({
     },
 });
 function normalizeOutputTarget(config, outputTarget) {
-    const results = Object.assign(Object.assign({}, outputTarget), { excludeComponents: outputTarget.excludeComponents || [], valueAccessorConfig: outputTarget.valueAccessorConfig || [] });
+    const results = Object.assign(Object.assign({}, outputTarget), { excludeComponents: outputTarget.excludeComponents || [], valueAccessorConfigs: outputTarget.valueAccessorConfigs || [] });
     if (config.rootDir == null) {
         throw new Error('rootDir is not set and it should be set by stencil itself');
     }
     if (outputTarget.directivesProxyFile == null) {
-        throw new Error('directivesProxyFile is required');
+        throw new Error('directivesProxyFile is required. Please set it in the Stencil config.');
     }
     if (outputTarget.directivesProxyFile && !path.isAbsolute(outputTarget.directivesProxyFile)) {
         results.directivesProxyFile = normalizePath(path.join(config.rootDir, outputTarget.directivesProxyFile));
@@ -360,9 +502,6 @@ function normalizeOutputTarget(config, outputTarget) {
     if (outputTarget.directivesArrayFile && !path.isAbsolute(outputTarget.directivesArrayFile)) {
         results.directivesArrayFile = normalizePath(path.join(config.rootDir, outputTarget.directivesArrayFile));
     }
-    if (outputTarget.directivesUtilsFile && !path.isAbsolute(outputTarget.directivesUtilsFile)) {
-        results.directivesUtilsFile = normalizePath(path.join(config.rootDir, outputTarget.directivesUtilsFile));
-    }
     return results;
 }
 
diff --git a/node_modules/@stencil/angular-output-target/dist/output-angular.js b/node_modules/@stencil/angular-output-target/dist/output-angular.js
index f61c96f..401533c 100644
--- a/node_modules/@stencil/angular-output-target/dist/output-angular.js
+++ b/node_modules/@stencil/angular-output-target/dist/output-angular.js
@@ -1,6 +1,6 @@
 import path from 'path';
-import { relativeImport, normalizePath, sortBy, readPackageJson, dashToPascalCase } from './utils';
-import { createComponentDefinition } from './generate-angular-component';
+import { relativeImport, normalizePath, sortBy, readPackageJson, dashToPascalCase, createImportStatement, } from './utils';
+import { createAngularComponentDefinition, createComponentTypeDefinition } from './generate-angular-component';
 import { generateAngularDirectivesFile } from './generate-angular-directives-file';
 import generateValueAccessors from './generate-value-accessors';
 export async function angularDirectiveProxyOutput(compilerCtx, outputTarget, components, config) {
@@ -37,10 +37,27 @@ export function generateProxies(components, pkgData, outputTarget, rootDir) {
     const distTypesDir = path.dirname(pkgData.types);
     const dtsFilePath = path.join(rootDir, distTypesDir, GENERATED_DTS);
     const componentsTypeFile = relativeImport(outputTarget.directivesProxyFile, dtsFilePath, '.d.ts');
+    /**
+     * The collection of named imports from @angular/core.
+     */
+    const angularCoreImports = [
+        'ChangeDetectionStrategy',
+        'ChangeDetectorRef',
+        'Component',
+        'ElementRef',
+        'EventEmitter',
+        'NgZone',
+        'Output',
+    ];
+    /**
+     * The collection of named imports from the angular-component-lib/utils.
+     */
+    const componentLibImports = ['ProxyCmp', 'proxyOutputs'];
     const imports = `/* tslint:disable */
 /* auto-generated angular directive proxies */
-import { ChangeDetectionStrategy, ChangeDetectorRef, Component, ElementRef, EventEmitter, NgZone } from '@angular/core';
-import { ProxyCmp, proxyOutputs } from './angular-component-lib/utils';\n`;
+${createImportStatement(angularCoreImports, '@angular/core')}
+
+${createImportStatement(componentLibImports, './angular-component-lib/utils')}\n`;
     /**
      * Generate JSX import type from correct location.
      * When using custom elements build, we need to import from
@@ -48,8 +65,12 @@ import { ProxyCmp, proxyOutputs } from './angular-component-lib/utils';\n`;
      * otherwise we risk bundlers pulling in lazy loaded imports.
      */
     const generateTypeImports = () => {
-        let importLocation = outputTarget.componentCorePackage ? normalizePath(outputTarget.componentCorePackage) : normalizePath(componentsTypeFile);
-        importLocation += outputTarget.includeImportCustomElements ? `/${outputTarget.customElementsDir || 'components'}` : '';
+        let importLocation = outputTarget.componentCorePackage
+            ? normalizePath(outputTarget.componentCorePackage)
+            : normalizePath(componentsTypeFile);
+        importLocation += outputTarget.includeImportCustomElements
+            ? `/${outputTarget.customElementsDir || 'components'}`
+            : '';
         return `import ${outputTarget.includeImportCustomElements ? 'type ' : ''}{ ${IMPORT_TYPES} } from '${importLocation}';\n`;
     };
     const typeImports = generateTypeImports();
@@ -61,21 +82,45 @@ import { ProxyCmp, proxyOutputs } from './angular-component-lib/utils';\n`;
      * IonButton React Component that takes in the Web Component as a parameter.
      */
     if (outputTarget.includeImportCustomElements && outputTarget.componentCorePackage !== undefined) {
-        const cmpImports = components.map(component => {
+        const cmpImports = components.map((component) => {
             const pascalImport = dashToPascalCase(component.tagName);
-            return `import { defineCustomElement as define${pascalImport} } from '${normalizePath(outputTarget.componentCorePackage)}/${outputTarget.customElementsDir ||
-                'components'}/${component.tagName}.js';`;
+            return `import { defineCustomElement as define${pascalImport} } from '${normalizePath(outputTarget.componentCorePackage)}/${outputTarget.customElementsDir || 'components'}/${component.tagName}.js';`;
         });
         sourceImports = cmpImports.join('\n');
     }
-    const final = [
-        imports,
-        typeImports,
-        sourceImports,
-        components
-            .map(createComponentDefinition(outputTarget.componentCorePackage, distTypesDir, rootDir, outputTarget.includeImportCustomElements, outputTarget.customElementsDir))
-            .join('\n'),
-    ];
+    const proxyFileOutput = [];
+    const filterInternalProps = (prop) => !prop.internal;
+    const mapPropName = (prop) => prop.name;
+    const { includeImportCustomElements, componentCorePackage, customElementsDir } = outputTarget;
+    for (let cmpMeta of components) {
+        const tagNameAsPascal = dashToPascalCase(cmpMeta.tagName);
+        const inputs = [];
+        if (cmpMeta.properties) {
+            inputs.push(...cmpMeta.properties.filter(filterInternalProps).map(mapPropName));
+        }
+        if (cmpMeta.virtualProperties) {
+            inputs.push(...cmpMeta.virtualProperties.map(mapPropName));
+        }
+        inputs.sort();
+        const outputs = [];
+        if (cmpMeta.events) {
+            outputs.push(...cmpMeta.events.filter(filterInternalProps));
+        }
+        const methods = [];
+        if (cmpMeta.methods) {
+            methods.push(...cmpMeta.methods.filter(filterInternalProps).map(mapPropName));
+        }
+        /**
+         * For each component, we need to generate:
+         * 1. The @Component decorated class
+         * 2. The component interface (using declaration merging for types).
+         */
+        const componentDefinition = createAngularComponentDefinition(cmpMeta.tagName, inputs, outputs, methods, includeImportCustomElements);
+        const componentTypeDefinition = createComponentTypeDefinition(tagNameAsPascal, cmpMeta.events, componentCorePackage, includeImportCustomElements, customElementsDir);
+        proxyFileOutput.push(componentDefinition, '\n');
+        proxyFileOutput.push(componentTypeDefinition, '\n');
+    }
+    const final = [imports, typeImports, sourceImports, ...proxyFileOutput];
     return final.join('\n') + '\n';
 }
 const GENERATED_DTS = 'components.d.ts';
diff --git a/node_modules/@stencil/angular-output-target/dist/plugin.d.ts b/node_modules/@stencil/angular-output-target/dist/plugin.d.ts
index 64f2e20..48f7e36 100644
--- a/node_modules/@stencil/angular-output-target/dist/plugin.d.ts
+++ b/node_modules/@stencil/angular-output-target/dist/plugin.d.ts
@@ -1,4 +1,4 @@
 import type { Config, OutputTargetCustom } from '@stencil/core/internal';
 import type { OutputTargetAngular } from './types';
 export declare const angularOutputTarget: (outputTarget: OutputTargetAngular) => OutputTargetCustom;
-export declare function normalizeOutputTarget(config: Config, outputTarget: any): OutputTargetAngular;
+export declare function normalizeOutputTarget(config: Config, outputTarget: OutputTargetAngular): OutputTargetAngular;
diff --git a/node_modules/@stencil/angular-output-target/dist/plugin.js b/node_modules/@stencil/angular-output-target/dist/plugin.js
index a124521..7038c59 100644
--- a/node_modules/@stencil/angular-output-target/dist/plugin.js
+++ b/node_modules/@stencil/angular-output-target/dist/plugin.js
@@ -14,12 +14,12 @@ export const angularOutputTarget = (outputTarget) => ({
     },
 });
 export function normalizeOutputTarget(config, outputTarget) {
-    const results = Object.assign(Object.assign({}, outputTarget), { excludeComponents: outputTarget.excludeComponents || [], valueAccessorConfig: outputTarget.valueAccessorConfig || [] });
+    const results = Object.assign(Object.assign({}, outputTarget), { excludeComponents: outputTarget.excludeComponents || [], valueAccessorConfigs: outputTarget.valueAccessorConfigs || [] });
     if (config.rootDir == null) {
         throw new Error('rootDir is not set and it should be set by stencil itself');
     }
     if (outputTarget.directivesProxyFile == null) {
-        throw new Error('directivesProxyFile is required');
+        throw new Error('directivesProxyFile is required. Please set it in the Stencil config.');
     }
     if (outputTarget.directivesProxyFile && !path.isAbsolute(outputTarget.directivesProxyFile)) {
         results.directivesProxyFile = normalizePath(path.join(config.rootDir, outputTarget.directivesProxyFile));
@@ -27,8 +27,5 @@ export function normalizeOutputTarget(config, outputTarget) {
     if (outputTarget.directivesArrayFile && !path.isAbsolute(outputTarget.directivesArrayFile)) {
         results.directivesArrayFile = normalizePath(path.join(config.rootDir, outputTarget.directivesArrayFile));
     }
-    if (outputTarget.directivesUtilsFile && !path.isAbsolute(outputTarget.directivesUtilsFile)) {
-        results.directivesUtilsFile = normalizePath(path.join(config.rootDir, outputTarget.directivesUtilsFile));
-    }
     return results;
 }
diff --git a/node_modules/@stencil/angular-output-target/dist/types.d.ts b/node_modules/@stencil/angular-output-target/dist/types.d.ts
index fe7e0e7..768a8ec 100644
--- a/node_modules/@stencil/angular-output-target/dist/types.d.ts
+++ b/node_modules/@stencil/angular-output-target/dist/types.d.ts
@@ -1,8 +1,15 @@
 export interface OutputTargetAngular {
-    componentCorePackage?: string;
+    /**
+     * The package name of the component library.
+     * This is used to generate the import statements.
+     */
+    componentCorePackage: string;
+    /**
+     * The path to the proxy file that will be generated. This can be an absolute path
+     * or a relative path from the root directory of the Stencil library.
+     */
     directivesProxyFile: string;
     directivesArrayFile?: string;
-    directivesUtilsFile?: string;
     valueAccessorConfigs?: ValueAccessorConfig[];
     excludeComponents?: string[];
     includeImportCustomElements?: boolean;
diff --git a/node_modules/@stencil/angular-output-target/dist/utils.d.ts b/node_modules/@stencil/angular-output-target/dist/utils.d.ts
index 618190c..32c70ba 100644
--- a/node_modules/@stencil/angular-output-target/dist/utils.d.ts
+++ b/node_modules/@stencil/angular-output-target/dist/utils.d.ts
@@ -1,4 +1,4 @@
-import { Config } from '@stencil/core/internal';
+import { ComponentCompilerEvent, Config } from '@stencil/core/internal';
 import type { PackageJSON } from './types';
 export declare const toLowerCase: (str: string) => string;
 export declare const dashToPascalCase: (str: string) => string;
@@ -7,3 +7,29 @@ export declare function normalizePath(str: string): string;
 export declare function relativeImport(pathFrom: string, pathTo: string, ext?: string): string;
 export declare function isRelativePath(path: string): boolean | "";
 export declare function readPackageJson(config: Config, rootDir: string): Promise<PackageJSON>;
+/**
+ * Formats an array of strings to a string of quoted, comma separated values.
+ * @param list The list of unformatted strings to format
+ * @returns The formatted array of strings. (e.g. ['foo', 'bar']) => `'foo', 'bar'`
+ */
+export declare const formatToQuotedList: (list: readonly string[]) => string;
+/**
+ * Creates an import statement for a list of named imports from a module.
+ * @param imports The list of named imports.
+ * @param module The module to import from.
+ *
+ * @returns The import statement as a string.
+ */
+export declare const createImportStatement: (imports: string[], module: string) => string;
+/**
+ * Creates the collection of import statements for a component based on the component's events type dependencies.
+ * @param componentTagName The tag name of the component (pascal case).
+ * @param events The events compiler metadata.
+ * @param options The options for generating the import statements (e.g. whether to import from the custom elements directory).
+ * @returns The import statements as an array of strings.
+ */
+export declare const createComponentEventTypeImports: (componentTagName: string, events: readonly ComponentCompilerEvent[], options: {
+    componentCorePackage: string;
+    includeImportCustomElements?: boolean;
+    customElementsDir?: string;
+}) => string;
diff --git a/node_modules/@stencil/angular-output-target/dist/utils.js b/node_modules/@stencil/angular-output-target/dist/utils.js
index 834f75d..8692633 100644
--- a/node_modules/@stencil/angular-output-target/dist/utils.js
+++ b/node_modules/@stencil/angular-output-target/dist/utils.js
@@ -74,6 +74,51 @@ export async function readPackageJson(config, rootDir) {
     }
     return pkgData;
 }
+/**
+ * Formats an array of strings to a string of quoted, comma separated values.
+ * @param list The list of unformatted strings to format
+ * @returns The formatted array of strings. (e.g. ['foo', 'bar']) => `'foo', 'bar'`
+ */
+export const formatToQuotedList = (list) => list.map((item) => `'${item}'`).join(', ');
+/**
+ * Creates an import statement for a list of named imports from a module.
+ * @param imports The list of named imports.
+ * @param module The module to import from.
+ *
+ * @returns The import statement as a string.
+ */
+export const createImportStatement = (imports, module) => {
+    if (imports.length === 0) {
+        return '';
+    }
+    return `import { ${imports.join(', ')} } from '${module}';`;
+};
+/**
+ * Creates the collection of import statements for a component based on the component's events type dependencies.
+ * @param componentTagName The tag name of the component (pascal case).
+ * @param events The events compiler metadata.
+ * @param options The options for generating the import statements (e.g. whether to import from the custom elements directory).
+ * @returns The import statements as an array of strings.
+ */
+export const createComponentEventTypeImports = (componentTagName, events, options) => {
+    const { componentCorePackage, includeImportCustomElements, customElementsDir } = options;
+    const imports = [];
+    const namedImports = new Set();
+    const importPathName = normalizePath(componentCorePackage) + (includeImportCustomElements ? `/${customElementsDir || 'components'}` : '');
+    events.forEach((event) => {
+        Object.entries(event.complexType.references).forEach(([typeName, refObject]) => {
+            if (refObject.location === 'local' || refObject.location === 'import') {
+                const newTypeName = `I${componentTagName}${typeName}`;
+                // Prevents duplicate imports for the same type.
+                if (!namedImports.has(newTypeName)) {
+                    imports.push(`import type { ${typeName} as ${newTypeName} } from '${importPathName}';`);
+                    namedImports.add(newTypeName);
+                }
+            }
+        });
+    });
+    return imports.join('\n');
+};
 const EXTENDED_PATH_REGEX = /^\\\\\?\\/;
 const NON_ASCII_REGEX = /[^\x00-\x80]+/;
 const SLASH_REGEX = /\\/g;
